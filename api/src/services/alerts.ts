/**
 * Alert Service - Splunk-style alert evaluation and execution
 *
 * Evaluates alert conditions, triggers actions, and manages alert state.
 */

import nodemailer from 'nodemailer';
import {
  Alert,
  AlertAction,
  AlertSeverity,
  getAlerts,
  getAlert,
  updateAlert,
  createAlertHistoryEntry,
  getRecentAlertTrigger,
  createAgentNotification,
  isAlertSilenced,
} from '../db/sqlite.js';
import { executeDSLQuery, getBackend } from '../db/backend.js';

// Parse time range string like "-5m", "-1h", "-24h" to milliseconds
function parseTimeRange(timeRange: string): number {
  const match = timeRange.match(/^-?(\d+)(s|m|h|d)$/);
  if (!match) return 5 * 60 * 1000; // Default 5 minutes

  const value = parseInt(match[1], 10);
  const unit = match[2];

  switch (unit) {
    case 's': return value * 1000;
    case 'm': return value * 60 * 1000;
    case 'h': return value * 60 * 60 * 1000;
    case 'd': return value * 24 * 60 * 60 * 1000;
    default: return 5 * 60 * 1000;
  }
}

// Check if trigger condition is met
function checkTriggerCondition(
  condition: string,
  value: number,
  threshold: number,
  previousValue?: number
): boolean {
  switch (condition) {
    case 'greater_than':
      return value > threshold;
    case 'less_than':
      return value < threshold;
    case 'equal_to':
      return value === threshold;
    case 'not_equal_to':
      return value !== threshold;
    case 'drops_by':
      if (previousValue === undefined) return false;
      return (previousValue - value) >= threshold;
    case 'rises_by':
      if (previousValue === undefined) return false;
      return (value - previousValue) >= threshold;
    default:
      return value > threshold;
  }
}

// Execute email action
async function executeEmailAction(
  alert: Alert,
  action: AlertAction,
  resultCount: number,
  sampleResults: Record<string, unknown>[]
): Promise<{ success: boolean; message: string }> {
  try {
    const config = action.config;
    if (!config.to) {
      return { success: false, message: 'No recipient specified' };
    }

    // Create transporter (uses SMTP settings from environment)
    const transporter = nodemailer.createTransport({
      host: process.env.SMTP_HOST || 'localhost',
      port: parseInt(process.env.SMTP_PORT || '25', 10),
      secure: process.env.SMTP_SECURE === 'true',
      auth: process.env.SMTP_USER ? {
        user: process.env.SMTP_USER,
        pass: process.env.SMTP_PASS,
      } : undefined,
    });

    // Build email
    const subject = config.subject || `[LogNog Alert] ${alert.name} - ${alert.severity.toUpperCase()}`;
    const body = config.body || `
Alert: ${alert.name}
Severity: ${alert.severity.toUpperCase()}
Time: ${new Date().toISOString()}
Results: ${resultCount}

Search Query: ${alert.search_query}

Sample Results:
${JSON.stringify(sampleResults.slice(0, 5), null, 2)}

---
This alert was generated by LogNog.
    `.trim();

    await transporter.sendMail({
      from: process.env.SMTP_FROM || 'lognog@localhost',
      to: config.to,
      subject,
      text: body,
    });

    return { success: true, message: `Email sent to ${config.to}` };
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Unknown error';
    return { success: false, message: `Email failed: ${message}` };
  }
}

// Execute webhook action
async function executeWebhookAction(
  alert: Alert,
  action: AlertAction,
  resultCount: number,
  sampleResults: Record<string, unknown>[]
): Promise<{ success: boolean; message: string }> {
  try {
    const config = action.config;
    if (!config.url) {
      return { success: false, message: 'No URL specified' };
    }

    const method = config.method || 'POST';
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
      ...config.headers,
    };

    // Build payload
    let payload: string;
    if (config.payload) {
      // Use custom payload template
      payload = config.payload
        .replace(/\{\{alert_name\}\}/g, alert.name)
        .replace(/\{\{alert_severity\}\}/g, alert.severity)
        .replace(/\{\{result_count\}\}/g, String(resultCount))
        .replace(/\{\{timestamp\}\}/g, new Date().toISOString())
        .replace(/\{\{search_query\}\}/g, alert.search_query)
        .replace(/\{\{sample_results\}\}/g, JSON.stringify(sampleResults.slice(0, 5)));
    } else {
      // Default payload
      payload = JSON.stringify({
        alert: {
          id: alert.id,
          name: alert.name,
          severity: alert.severity,
          search_query: alert.search_query,
        },
        trigger: {
          timestamp: new Date().toISOString(),
          result_count: resultCount,
        },
        sample_results: sampleResults.slice(0, 10),
      });
    }

    const response = await fetch(config.url, {
      method,
      headers,
      body: method !== 'GET' ? payload : undefined,
    });

    if (response.ok) {
      return { success: true, message: `Webhook ${method} ${config.url} - ${response.status}` };
    } else {
      return { success: false, message: `Webhook failed: ${response.status} ${response.statusText}` };
    }
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Unknown error';
    return { success: false, message: `Webhook failed: ${message}` };
  }
}

// Execute log action (write to file or console)
async function executeLogAction(
  alert: Alert,
  action: AlertAction,
  resultCount: number
): Promise<{ success: boolean; message: string }> {
  const logMessage = `[${new Date().toISOString()}] ALERT: ${alert.name} (${alert.severity}) - ${resultCount} results`;
  console.log(logMessage);
  return { success: true, message: 'Logged to console' };
}

// Execute all actions for an alert
async function executeActions(
  alert: Alert,
  resultCount: number,
  sampleResults: Record<string, unknown>[]
): Promise<{ type: string; success: boolean; message: string }[]> {
  const actions: AlertAction[] = JSON.parse(alert.actions || '[]');
  const results: { type: string; success: boolean; message: string }[] = [];

  for (const action of actions) {
    let result: { success: boolean; message: string };

    switch (action.type) {
      case 'email':
        result = await executeEmailAction(alert, action, resultCount, sampleResults);
        break;
      case 'webhook':
        result = await executeWebhookAction(alert, action, resultCount, sampleResults);
        break;
      case 'log':
        result = await executeLogAction(alert, action, resultCount);
        break;
      default:
        result = { success: false, message: `Unknown action type: ${action.type}` };
    }

    results.push({ type: action.type, ...result });
  }

  return results;
}

// Evaluate a single alert
export async function evaluateAlert(alertId: string): Promise<{
  triggered: boolean;
  resultCount: number;
  message: string;
}> {
  const alert = getAlert(alertId);
  if (!alert) {
    return { triggered: false, resultCount: 0, message: 'Alert not found' };
  }

  if (!alert.enabled) {
    return { triggered: false, resultCount: 0, message: 'Alert is disabled' };
  }

  try {
    // Calculate time range
    const timeRangeMs = parseTimeRange(alert.time_range);
    const earliest = new Date(Date.now() - timeRangeMs).toISOString();
    const latest = new Date().toISOString();

    // Execute the search query
    const { results } = await executeDSLQuery(alert.search_query, { earliest, latest });
    const resultCount = results.length;

    // Update last_run timestamp
    updateAlert(alertId, { last_run: new Date().toISOString() });

    // Check trigger condition
    let triggered = false;

    switch (alert.trigger_type) {
      case 'number_of_results':
        triggered = checkTriggerCondition(
          alert.trigger_condition,
          resultCount,
          alert.trigger_threshold
        );
        break;

      case 'number_of_hosts':
        // Count unique hosts
        const uniqueHosts = new Set(
          results.map((r: Record<string, unknown>) => r.hostname || r.host || r.source)
        );
        triggered = checkTriggerCondition(
          alert.trigger_condition,
          uniqueHosts.size,
          alert.trigger_threshold
        );
        break;

      case 'custom_condition':
        // For custom conditions, just check if any results
        triggered = resultCount > 0;
        break;
    }

    if (!triggered) {
      return { triggered: false, resultCount, message: 'Condition not met' };
    }

    // Check if alert is silenced
    // Extract hostname from results if available
    const hostname = results.length > 0
      ? (results[0] as Record<string, unknown>).hostname as string || undefined
      : undefined;

    if (isAlertSilenced(alertId, hostname)) {
      return {
        triggered: false,
        resultCount,
        message: 'Alert is silenced',
      };
    }

    // Check throttling
    if (alert.throttle_enabled) {
      const recentTrigger = getRecentAlertTrigger(alertId, alert.throttle_window_seconds);
      if (recentTrigger) {
        return {
          triggered: false,
          resultCount,
          message: `Throttled - last triggered at ${recentTrigger.triggered_at}`,
        };
      }
    }

    // Execute actions
    const actionResults = await executeActions(
      alert,
      resultCount,
      results.slice(0, 10) as Record<string, unknown>[]
    );

    // Record in history
    createAlertHistoryEntry(
      alertId,
      resultCount,
      alert.severity as AlertSeverity,
      {
        trigger_value: String(resultCount),
        actions_executed: actionResults,
        sample_results: results.slice(0, 5) as Record<string, unknown>[],
      }
    );

    // Update alert statistics
    updateAlert(alertId, {
      last_triggered: new Date().toISOString(),
      trigger_count: (alert.trigger_count || 0) + 1,
    });

    // Create agent notification (push to system tray)
    createAgentNotification(
      alert.name,
      `Alert: ${alert.name}`,
      `${alert.severity.toUpperCase()} - ${resultCount} results found matching: ${alert.search_query.substring(0, 100)}`,
      {
        alert_id: alertId,
        severity: alert.severity as AlertSeverity,
        // Expire after 24 hours
        expires_at: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),
      }
    );

    console.log(`Alert triggered: ${alert.name} (${resultCount} results)`);

    return {
      triggered: true,
      resultCount,
      message: `Alert triggered - ${actionResults.filter(r => r.success).length}/${actionResults.length} actions succeeded`,
    };
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Unknown error';
    console.error(`Error evaluating alert ${alert.name}:`, message);
    return { triggered: false, resultCount: 0, message: `Error: ${message}` };
  }
}

// Evaluate all enabled alerts
export async function evaluateAllAlerts(): Promise<{
  evaluated: number;
  triggered: number;
  errors: number;
}> {
  const alerts = getAlerts(true); // Get enabled alerts only
  let evaluated = 0;
  let triggered = 0;
  let errors = 0;

  for (const alert of alerts) {
    const result = await evaluateAlert(alert.id);
    evaluated++;

    if (result.triggered) {
      triggered++;
    } else if (result.message.startsWith('Error:')) {
      errors++;
    }
  }

  return { evaluated, triggered, errors };
}

// Test an alert without saving to history
export async function testAlert(
  searchQuery: string,
  triggerType: string,
  triggerCondition: string,
  triggerThreshold: number,
  timeRange: string
): Promise<{
  wouldTrigger: boolean;
  resultCount: number;
  sampleResults: Record<string, unknown>[];
  message: string;
}> {
  try {
    // Calculate time range
    const timeRangeMs = parseTimeRange(timeRange);
    const earliest = new Date(Date.now() - timeRangeMs).toISOString();
    const latest = new Date().toISOString();

    // Execute the search query
    const { results } = await executeDSLQuery(searchQuery, { earliest, latest });
    const resultCount = results.length;

    // Check trigger condition
    let wouldTrigger = false;

    switch (triggerType) {
      case 'number_of_results':
        wouldTrigger = checkTriggerCondition(triggerCondition, resultCount, triggerThreshold);
        break;

      case 'number_of_hosts':
        const uniqueHosts = new Set(
          results.map((r: Record<string, unknown>) => r.hostname || r.host || r.source)
        );
        wouldTrigger = checkTriggerCondition(triggerCondition, uniqueHosts.size, triggerThreshold);
        break;

      case 'custom_condition':
        wouldTrigger = resultCount > 0;
        break;
    }

    return {
      wouldTrigger,
      resultCount,
      sampleResults: results.slice(0, 10) as Record<string, unknown>[],
      message: wouldTrigger
        ? `Would trigger (${resultCount} results)`
        : `Would not trigger (${resultCount} results)`,
    };
  } catch (error) {
    const message = error instanceof Error ? error.message : 'Unknown error';
    return {
      wouldTrigger: false,
      resultCount: 0,
      sampleResults: [],
      message: `Error: ${message}`,
    };
  }
}
